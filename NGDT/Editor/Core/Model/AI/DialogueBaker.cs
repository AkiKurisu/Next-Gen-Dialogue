using System.Collections.Generic;
using UnityEngine;
using System.Threading.Tasks;
using Kurisu.NGDS;
using System;
using Kurisu.NGDS.AI;
using System.Threading;
using System.Linq;
using UnityEditor;
using System.Text;
namespace Kurisu.NGDT.Editor
{
    public class DialogueBaker
    {
        private const float maxWaitSeconds = 60.0f;
        public string UserName { get; set; } = "User";
        public string BotName { get; set; } = "Bot";
        private AIPromptBuilder builder;
        /// <summary>
        /// Generate dialogue for selected container node by path from selection
        /// </summary>
        /// <param name="treeView"></param>
        /// <returns></returns>
        public static async Task GenerateDialogue(IDialogueTreeView treeView)
        {
            var containers = treeView.View.selection.OfType<ContainerNode>().ToList();
            if (containers.Count == 0) return;
            var bakeContainer = containers.Last();
            containers.Remove(bakeContainer);
            float startVal = (float)EditorApplication.timeSinceStartup;
            var ct = treeView.GetCancellationTokenSource();
            DialogueBaker baker = new();
            var task = baker.Bake(containers, bakeContainer, ct.Token);
            while (!task.IsCompleted)
            {
                float slider = (float)(EditorApplication.timeSinceStartup - startVal) / maxWaitSeconds;
                EditorUtility.DisplayProgressBar("Wait to bake dialogue", "Waiting for a few seconds", slider);
                if (slider > 1)
                {
                    treeView.EditorWindow.ShowNotification(new GUIContent($"Dialogue baking is out of time, please check your internet!"));
                    ct.Cancel();
                    break;
                }
                await Task.Yield();
            }
            if (!task.IsCanceled && !task.Result)
            {
                treeView.EditorWindow.ShowNotification(new GUIContent($"Dialogue baking failed"));
            }
            EditorUtility.ClearProgressBar();
        }
        public static async Task AutoGenerateDialogue(IDialogueTreeView treeView)
        {
            var containers = treeView.View.selection.OfType<ContainerNode>().ToList();
            if (containers.Count == 0) return;
            DialogueBaker baker = new();
            var bakeContainer = containers.Last();
            containers.Remove(bakeContainer);
            bakeContainer.TryGetModuleNode<AIBakeModule>(out ModuleNode aiBakeModule);
            int depth = (int)aiBakeModule.GetFieldResolver("generateDepth").Value;
            int option = (int)aiBakeModule.GetFieldResolver("optionCount").Value;
            float startVal = (float)EditorApplication.timeSinceStartup;
            var ct = treeView.GetCancellationTokenSource();
            int step = 0;
            var task = Generate(containers, bakeContainer, ct.Token, 0, depth);
            while (!task.IsCompleted)
            {
                float slider = (float)(EditorApplication.timeSinceStartup - startVal) / maxWaitSeconds;
                EditorUtility.DisplayProgressBar($"Wait to bake dialogue, step {step}", "Waiting for a few seconds", slider);
                if (slider > 1)
                {
                    treeView.EditorWindow.ShowNotification(new GUIContent($"Dialogue baking is out of time, please check your internet!"));
                    ct.Cancel();
                    break;
                }
                await Task.Yield();
            }
            if (!task.IsCanceled && !task.Result)
            {
                treeView.EditorWindow.ShowNotification(new GUIContent($"Dialogue baking failed"));
            }
            EditorUtility.ClearProgressBar();
            await Task.Delay(2);
            //Auto layout
            NodeAutoLayoutHelper.Layout(new DialogueTreeLayoutConvertor(treeView.View, bakeContainer));

            async Task<bool> Generate(IReadOnlyList<ContainerNode> containers, ContainerNode bakeContainer, CancellationToken ct, int currentDepth, int maxDepth)
            {
                step++;
                if (!await baker.Bake(containers, bakeContainer, ct)) return false;
                if (currentDepth >= maxDepth) return true;
                // Append current bake to last
                containers = new List<ContainerNode>(containers)
                {
                    bakeContainer
                };
                int count = bakeContainer is PieceContainer ? option : 1;
                for (int i = 0; i < count; i++)
                {
                    // Create next container
                    var node = treeView.CreateNextContainer(bakeContainer);
                    // Link nodes
                    treeView.ConnectContainerNodes(bakeContainer, node);
                    // Add bake module from script
                    // Random character
                    node.AddModuleNode(new AIBakeModule(depth, option));
                    if (!await Generate(containers, node, ct, currentDepth + 1, maxDepth)) return false;
                    node.RemoveModule<AIBakeModule>();
                }
                return true;
            }
        }
        public AIPromptBuilder GetLastBuilder()
        {
            return builder;
        }
        /// <summary>
        /// Bake Dialogue Content in target container based on user's node selection
        /// </summary>
        /// <param name="containerNodes"></param>
        /// <param name="bakeContainerNode"></param>
        /// <param name="ct"></param>
        /// <returns></returns>
        public async Task<bool> Bake(IReadOnlyList<ContainerNode> containerNodes, ContainerNode bakeContainerNode, CancellationToken ct)
        {

            //No need to cache history, instance new is better
            builder = new AIPromptBuilder(CreateLLM());
            //Append user designed dialogue
            for (int i = 0; i < containerNodes.Count; i++)
            {
                AppendDialogue(containerNodes[i], builder);
            }
            //Generate dialogue from llm finally
            try
            {
                return await GenerateDialogue(bakeContainerNode, ct);
            }
            catch (OperationCanceledException)
            {
                Debug.LogWarning($"[Dialogue Baker] Bake was cancelled");
                return false;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[Dialogue Baker] {ex.Message}");
                return false;
            }
        }
        private static ILargeLanguageModel CreateLLM()
        {
            var setting = NextGenDialogueSetting.GetOrCreateSettings().AITurboSetting;
            return LLMFactory.CreateLLM(setting);
        }
        private async Task<bool> GenerateDialogue(ContainerNode containerNode, CancellationToken ct)
        {
            try
            {
                var response = (await builder.GenerateAsync(ct)).Response;
                //Remove original module node since container can only contain one module for each type
                containerNode.RemoveModule<ContentModule>();
                //Create output module node
                containerNode.AddModuleNode(new ContentModule(response));
                return true;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[Dialogue Baker] {ex}");
                return false;
            }
        }
        private bool TrySetPrompt(ContainerNode containerNode, out string prompt)
        {
            prompt = null;
            if (containerNode.TryGetModuleNode<SystemPromptModule>(out ModuleNode promptModule))
            {
                prompt = promptModule.GetSharedStringValue("prompt");
                return true;
            }
            else if (containerNode.TryGetModuleNode<PromptPresetModule>(out ModuleNode promptPresetModule))
            {
                var text = promptPresetModule.GetSharedVariableValue<TextAsset>("prompt");
                if (text == null)
                {
                    Debug.LogError($"[Dialogue Baker] Prompt file is empty in {containerNode}");
                    return false;
                }
                prompt = text.text;
                return true;
            }
            else if (containerNode.TryGetModuleNode<CharacterPresetModule>(out ModuleNode presetModule))
            {
                var user_Name = presetModule.GetSharedStringValue("user_Name");
                var char_name = presetModule.GetSharedStringValue("char_name");
                var char_persona = presetModule.GetSharedStringValue("char_persona");
                var world_scenario = presetModule.GetSharedStringValue("world_scenario");
                prompt = ChatPromptHelper.ConstructPrompt(user_Name, char_name, char_persona, world_scenario);
                return true;
            }
            return false;
        }
        private void AppendDialogue(ContainerNode containerNode, AIPromptBuilder builder)
        {
            if (containerNode is DialogueContainer && TrySetPrompt(containerNode, out string prompt))
            {
                builder.SetSystemPrompt(prompt);
                return;
            }
            MessageRole role = containerNode is OptionContainer ? MessageRole.User : MessageRole.Bot;
            if (!containerNode.TryGetModuleNode<ContentModule>(out ModuleNode contentModule)) return;
            string content = contentModule.GetSharedStringValue("content");
            builder.Append(role, content);
        }
        private string GetName(MessageRole role)
        {
            return role == MessageRole.User ? UserName : BotName;
        }
        /// <summary>
        /// Generate a test bake content for editor test purpose
        /// </summary>
        /// <param name="containerNodes"></param>
        /// <param name="bakeContainerNode"></param>
        /// <returns></returns> <summary>
        public string Preview(IReadOnlyList<ContainerNode> containerNodes, ContainerNode bakeContainerNode)
        {
            StringBuilder stringBuilder = new();
            //Append user designed dialogue
            for (int i = 0; i < containerNodes.Count; i++)
            {
                AppendDialogue(containerNodes[i], stringBuilder);
            }
            MessageRole role = bakeContainerNode is OptionContainer ? MessageRole.User : MessageRole.Bot;
            stringBuilder.Append($"{GetName(role)}:");
            return stringBuilder.ToString();
        }
        private void AppendDialogue(ContainerNode containerNode, StringBuilder builder)
        {
            if (containerNode is DialogueContainer && TrySetPrompt(containerNode, out string prompt))
            {
                builder.Insert(0, '\n');
                builder.Insert(0, prompt);
                return;
            }
            MessageRole role = containerNode is OptionContainer ? MessageRole.User : MessageRole.Bot;
            if (!containerNode.TryGetModuleNode<ContentModule>(out ModuleNode contentModule)) return;
            string content = contentModule.GetSharedStringValue("content");
            builder.Append(GetName(role));
            builder.Append(':');
            builder.AppendLine(content);
        }
    }
}
