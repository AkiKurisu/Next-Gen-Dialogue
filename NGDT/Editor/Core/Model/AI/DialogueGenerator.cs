using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Kurisu.NGDS;
using UnityEditor;
using UnityEngine;
namespace Kurisu.NGDT.Editor
{
    /// <summary>
    /// Editor Dialogue Generation API
    /// </summary>
    public static class DialogueGenerateExtension
    {
        private static readonly DialogueBaker baker = new();
        private const float maxWaitSeconds = 60.0f;
        /// <summary>
        /// Generate dialogue for selected container node by path from selection
        /// </summary>
        /// <param name="treeView"></param>
        /// <returns></returns>
        public static async Task GenerateDialogue(this IDialogueTreeView treeView)
        {
            var containers = treeView.View.selection.OfType<ContainerNode>().ToList();
            if (containers.Count == 0) return;
            var bakeContainer = containers.Last();
            containers.Remove(bakeContainer);
            float startVal = (float)EditorApplication.timeSinceStartup;
            var ct = new CancellationTokenSource();
            var task = baker.Bake(containers, bakeContainer, ct.Token);
            while (!task.IsCompleted)
            {
                float slider = (float)(EditorApplication.timeSinceStartup - startVal) / maxWaitSeconds;
                EditorUtility.DisplayProgressBar("Wait to bake dialogue", "Waiting for a few seconds", slider);
                if (slider > 1)
                {
                    treeView.EditorWindow.ShowNotification(new GUIContent($"Dialogue baking is out of time, please check your internet!"));
                    ct.Cancel();
                    break;
                }
                await Task.Yield();
            }
            EditorUtility.ClearProgressBar();
        }
        public static async Task AutoGenerateDialogue(this IDialogueTreeView treeView)
        {
            var containers = treeView.View.selection.OfType<ContainerNode>().ToList();
            if (containers.Count == 0) return;
            var bakeContainer = containers.Last();
            containers.Remove(bakeContainer);
            bakeContainer.TryGetModuleNode<AIBakeModule>(out ModuleNode aiBakeModule);
            LLMType llmType = (LLMType)aiBakeModule.GetFieldResolver("llmType").Value;
            int depth = (int)aiBakeModule.GetFieldResolver("generateDepth").Value;
            int option = (int)aiBakeModule.GetFieldResolver("optionCount").Value;
            float startVal = (float)EditorApplication.timeSinceStartup;
            var ct = new CancellationTokenSource();
            int step = 0;
            var task = Generate(containers, bakeContainer, new(), 0, depth);
            while (!task.IsCompleted)
            {
                float slider = (float)(EditorApplication.timeSinceStartup - startVal) / maxWaitSeconds;
                EditorUtility.DisplayProgressBar($"Wait to bake dialogue, step {step}", "Waiting for a few seconds", slider);
                if (slider > 1)
                {
                    treeView.EditorWindow.ShowNotification(new GUIContent($"Dialogue baking is out of time, please check your internet!"));
                    ct.Cancel();
                    break;
                }
                await Task.Yield();
            }
            EditorUtility.ClearProgressBar();
            await Task.Delay(2);
            //Auto layout
            NodeAutoLayoutHelper.Layout(new DialogueTreeLayoutConvertor(treeView.View, bakeContainer as ILayoutTreeNode));

            async Task Generate(IReadOnlyList<ContainerNode> containers, ContainerNode bakeContainer, CancellationToken ct, int currentDepth, int maxDepth)
            {
                step++;
                await baker.Bake(containers, bakeContainer, ct);
                if (currentDepth >= maxDepth) return;
                var character = baker.GetLastBuilder().GetCharacters().RandomElement();
                // Append current bake to last
                containers = new List<ContainerNode>(containers)
                {
                    bakeContainer
                };
                int count = bakeContainer is PieceContainer ? option : 1;
                for (int i = 0; i < count; i++)
                {
                    // Create next container
                    var node = treeView.CreateNextContainer(bakeContainer);
                    // Link nodes
                    treeView.ConnectContainerNodes(bakeContainer, node);
                    // Add bake module from script
                    // Random character
                    node.AddModuleNode(new AIBakeModule(character, llmType, depth, option));
                    await Generate(containers, node, ct, currentDepth + 1, maxDepth);
                    node.RemoveModule<AIBakeModule>();
                }
            }
        }


    }
    public static class GeneratorExtensions
    {
        private static readonly System.Random _random = new();
        public static ContainerNode CreateNextContainer(this IDialogueTreeView treeView, ContainerNode first)
        {
            Type nextNodeType = first is PieceContainer ? typeof(Option) : typeof(Piece);
            var node = NodeResolverFactory.Instance.Create(nextNodeType, treeView) as ContainerNode;
            var rect = first.GetPosition();
            rect.x += rect.width + 300;
            treeView.AddNode(node, rect);
            return node;
        }
        public static void ConnectContainerNodes(this IDialogueTreeView treeView, ContainerNode first, ContainerNode second)
        {
            if (first is PieceContainer pieceContainer)
            {
                pieceContainer.AddChildElement(second, treeView);
            }
            else
            {
                var optionNode = first as OptionContainer;
                var pieceNode = second as PieceContainer;
                pieceNode.GenerateNewPieceID();
                optionNode.AddModuleNode(new TargetIDModule(pieceNode.GetPieceID()));
            }
        }
        public static T RandomElement<T>(this IEnumerable<T> enumerable)
        {
            if (enumerable == null)
            {
                throw new ArgumentNullException(nameof(enumerable));
            }

            int count = 0;
            T selected = default;

            foreach (T element in enumerable)
            {
                count++;
                if (_random.Next(count) == 0)
                {
                    selected = element;
                }
            }

            if (count == 0)
            {
                throw new InvalidOperationException("Sequence contains no elements");
            }
            return selected;
        }
    }
}